diff --git a/cmake_modules/FindBrotli.cmake b/cmake_modules/FindBrotli.cmake
index 6b631ab..da5b6d2 100644
--- a/cmake_modules/FindBrotli.cmake
+++ b/cmake_modules/FindBrotli.cmake
@@ -23,9 +23,9 @@ include(FindPackageHandleStandardArgs)
 
 find_path(BROTLI_INCLUDE_DIR "brotli/decode.h")
 
-find_library(BROTLICOMMON_LIBRARY NAMES brotlicommon)
-find_library(BROTLIDEC_LIBRARY NAMES brotlidec)
-find_library(BROTLIENC_LIBRARY NAMES brotlienc)
+find_library(BROTLICOMMON_LIBRARY NAMES brotlicommon brotlicommon-static)
+find_library(BROTLIDEC_LIBRARY NAMES brotlidec brotlidec-static)
+find_library(BROTLIENC_LIBRARY NAMES brotlienc brotlienc-static)
 
 find_package_handle_standard_args(Brotli
                                   REQUIRED_VARS
diff --git a/lib/inc/drogon/Cookie.h b/lib/inc/drogon/Cookie.h
index e31b0d5..84a2bf2 100644
--- a/lib/inc/drogon/Cookie.h
+++ b/lib/inc/drogon/Cookie.h
@@ -1,6 +1,6 @@
 /**
  *
- *  @file Cookis.h
+ *  @file Cookie.h
  *  @author An Tao
  *
  *  Copyright 2018, An Tao.  All rights reserved.
diff --git a/lib/inc/drogon/HttpResponse.h b/lib/inc/drogon/HttpResponse.h
index 47b80fa..3066cf2 100644
--- a/lib/inc/drogon/HttpResponse.h
+++ b/lib/inc/drogon/HttpResponse.h
@@ -129,10 +129,10 @@ class DROGON_EXPORT HttpResponse
      */
     virtual void setCloseConnection(bool on) = 0;
 
-    /// Get the status set by the setCloseConnetion() method.
+    /// Get the status set by the setCloseConnection() method.
     virtual bool ifCloseConnection() const = 0;
 
-    /// Set the response content type, such as text/html, text/plaint, image/png
+    /// Set the response content type, such as text/html, text/plain, image/png
     /// and so on. If the content type
     /// is a text type, the character set is utf8.
     virtual void setContentTypeCode(ContentType type) = 0;
@@ -423,6 +423,25 @@ class DROGON_EXPORT HttpResponse
         ContentType type = CT_NONE,
         const std::string &typeString = "");
 
+    /// Create a response that returns a file to the client from a callback function
+    /**
+     * @note if the Connection is keep-alive and the Content-Length header is not set,
+     *       the stream data is sent with Transfer-Encoding: chunked.
+     * @param function to retrieve the stream data (stream ends when a zero size is returned)
+     *                 the callback will be called with nullptr when the send is finished/interruped so that it cleans up its internals.
+     * @param attachmentFileName if the parameter is not empty, the browser
+     *                           does not open the file, but saves it as an attachment.
+     * @param type the content type code. If the parameter is CT_NONE, the
+     *             content type is set by drogon based on the file extension and typeString.
+     *             Set it to CT_CUSTOM when no drogon internal content type matches.
+     * @param typeString the MIME string of the content type.
+     */
+    static HttpResponsePtr newStreamResponse(
+        const std::function<std::size_t(char*, std::size_t)>& callback,
+        const std::string &attachmentFileName = "",
+        ContentType type = CT_NONE,
+        const std::string &typeString = "");
+
     /**
      * @brief Create a custom HTTP response object. For using this template,
      * users must specialize the toResponse template.
@@ -449,7 +468,14 @@ class DROGON_EXPORT HttpResponse
     virtual const SendfileRange &sendfileRange() const = 0;
 
     /**
-     * @brief Rreturns the content type associated with the response
+     * @brief If the response is a stream response (i.e. created by
+     * newStreamResponse) returns the callback function. Otherwise a
+     * null function.
+     */
+    virtual const std::function<std::size_t(char*, std::size_t)>& streamCallback() const = 0;
+
+    /**
+     * @brief Returns the content type associated with the response
      */
     virtual std::string contentTypeString() const = 0;
 
diff --git a/lib/src/HttpResponseImpl.cc b/lib/src/HttpResponseImpl.cc
index 99ade8b..8648fdd 100644
--- a/lib/src/HttpResponseImpl.cc
+++ b/lib/src/HttpResponseImpl.cc
@@ -27,6 +27,11 @@
 
 using namespace trantor;
 using namespace drogon;
+using namespace std::literals::string_literals;
+using namespace std::placeholders;
+#ifdef _WIN32
+#undef max
+#endif
 
 namespace drogon
 {
@@ -400,6 +405,68 @@ HttpResponsePtr HttpResponse::newFileResponse(
     return resp;
 }
 
+HttpResponsePtr HttpResponse::newStreamResponse(
+    const std::function<std::size_t(char *, std::size_t)>& callback,
+    const std::string &attachmentFileName,
+    ContentType type,
+    const std::string &typeString)
+{
+    LOG_TRACE << "send stream as "s
+              << (attachmentFileName.empty() ? "raw data"s
+                                             : "file: "s + attachmentFileName);
+    if (!callback)
+    {
+        auto resp = HttpResponse::newNotFoundResponse();
+        return resp;
+    }
+    auto resp = std::make_shared<HttpResponseImpl>();
+    resp->setStreamCallback(callback);
+    resp->setStatusCode(k200OK);
+
+    // Infer content type
+    if (type == CT_NONE)
+    {
+        if (!typeString.empty())
+        {
+            auto r = static_cast<HttpResponse*>(resp.get());
+            auto contentType = type;
+            if (type == CT_NONE)
+                type = parseContentType(typeString);
+            if (type == CT_NONE)
+                type = CT_CUSTOM;  // XXX: Is this Ok?
+            r->setContentTypeCodeAndCustomString(type, typeString);
+        }
+        else if (!attachmentFileName.empty())
+        {
+            resp->setContentTypeCode(drogon::getContentType(attachmentFileName));
+        }
+    }
+    else
+    {
+        if (typeString.empty())
+            resp->setContentTypeCode(type);
+        else
+        {
+            auto r = static_cast<HttpResponse*>(resp.get());
+            auto contentType = type;
+            if (type == CT_NONE)
+                type = parseContentType(typeString);
+            if (type == CT_NONE)
+                type = CT_CUSTOM;  // XXX: Is this Ok?
+            r->setContentTypeCodeAndCustomString(type, typeString);
+        }
+    }
+
+    // Set headers
+    if (!attachmentFileName.empty())
+    {
+        resp->addHeader("Content-Disposition",
+                        "attachment; filename=" + attachmentFileName);
+    }
+    doResponseCreateAdvices(resp);
+    return resp;
+}
+
 void HttpResponseImpl::makeHeaderString(trantor::MsgBuffer &buffer)
 {
     buffer.ensureWritableBytes(128);
@@ -447,7 +514,19 @@ void HttpResponseImpl::makeHeaderString(trantor::MsgBuffer &buffer)
     if (!passThrough_)
     {
         buffer.ensureWritableBytes(64);
-        if (sendfileName_.empty())
+        if (streamCallback_)
+        {
+            // When the headers are created, it is time to set the transfer
+            // encoding to chunked if the contents size is not specified
+            if (!ifCloseConnection() &&
+                headers_.find("content-length") == headers_.end())
+            {
+                LOG_DEBUG << "send stream with transfer-encoding chunked";
+                headers_["transfer-encoding"] = "chunked";
+            }
+            len = 0;
+        }
+        else if (sendfileName_.empty())
         {
             auto bodyLength = bodyPtr_ ? bodyPtr_->length() : 0;
             len = snprintf(buffer.beginWrite(),
@@ -789,6 +868,7 @@ void HttpResponseImpl::swap(HttpResponseImpl &that) noexcept
     swap(flagForParsingContentType_, that.flagForParsingContentType_);
     swap(flagForParsingJson_, that.flagForParsingJson_);
     swap(sendfileName_, that.sendfileName_);
+    swap(streamCallback_, that.streamCallback_);
     jsonPtr_.swap(that.jsonPtr_);
     fullHeaderString_.swap(that.fullHeaderString_);
     httpString_.swap(that.httpString_);
@@ -804,6 +884,12 @@ void HttpResponseImpl::clear()
     fullHeaderString_.reset();
     jsonParsingErrorPtr_.reset();
     sendfileName_.clear();
+    if (streamCallback_)
+    {
+        LOG_TRACE << "Cleanup HttpResponse stream callback";
+        streamCallback_(nullptr, 0);  // callback internal cleanup
+        streamCallback_ = {};
+    }
     headers_.clear();
     cookies_.clear();
     bodyPtr_.reset();
@@ -850,7 +936,8 @@ void HttpResponseImpl::parseJson() const
 
 bool HttpResponseImpl::shouldBeCompressed() const
 {
-    if (!sendfileName_.empty() ||
+    if (streamCallback_ ||
+        !sendfileName_.empty() ||
         contentType() >= CT_APPLICATION_OCTET_STREAM ||
         getBody().length() < 1024 || !(getHeaderBy("content-encoding").empty()))
     {
diff --git a/lib/src/HttpResponseImpl.h b/lib/src/HttpResponseImpl.h
index ea3cb30..a41d6fe 100644
--- a/lib/src/HttpResponseImpl.h
+++ b/lib/src/HttpResponseImpl.h
@@ -311,6 +311,14 @@ class DROGON_EXPORT HttpResponseImpl : public HttpResponse
         sendfileRange_.first = offset;
         sendfileRange_.second = len;
     }
+    const std::function<std::size_t(char*, std::size_t)>& streamCallback() const override
+    {
+        return streamCallback_;
+    }
+    void setStreamCallback(const std::function<std::size_t(char*, std::size_t)>& callback)
+    {
+        streamCallback_ = callback;
+    }
     void makeHeaderString()
     {
         fullHeaderString_ = std::make_shared<trantor::MsgBuffer>(128);
@@ -440,6 +448,7 @@ class DROGON_EXPORT HttpResponseImpl : public HttpResponse
     ssize_t expriedTime_{-1};
     std::string sendfileName_;
     SendfileRange sendfileRange_{0, 0};
+    std::function<std::size_t(char *, std::size_t)> streamCallback_;
 
     mutable std::shared_ptr<Json::Value> jsonPtr_;
 
diff --git a/lib/src/HttpServer.cc b/lib/src/HttpServer.cc
index ab5a69d..5f1a3fe 100644
--- a/lib/src/HttpServer.cc
+++ b/lib/src/HttpServer.cc
@@ -547,6 +547,111 @@ void HttpServer::onRequests(
     }
 }
 
+using CallbackParams = struct
+{
+    std::function<std::size_t(char *, std::size_t)> dataCallback;
+    bool bFinished;
+#ifndef NDEBUG  // defined by CMake for release build
+    std::size_t nDataReturned;
+#endif
+};
+static std::size_t chunkingCallback(std::shared_ptr<CallbackParams> cbParams,
+                                    char *pBuffer,
+                                    std::size_t nSize)
+{
+    if (!cbParams)
+        return 0;
+    // Cleanup
+    if (pBuffer == nullptr)
+    {
+        LOG_TRACE << "Chunking callback cleanup";
+        if (cbParams && cbParams->dataCallback)
+        {
+            cbParams->dataCallback(pBuffer, nSize);
+            cbParams->dataCallback = {};
+            cbParams.reset();
+        }
+        return 0;
+    }
+    // Terminal chunk already returned
+    if (cbParams->bFinished)
+    {
+        LOG_TRACE << "Chunking callback has no more data";
+#ifndef NDEBUG  // defined by CMake for release build
+        LOG_TRACE << "Chunking callback: total data returned: "
+                  << cbParams->nDataReturned << " bytes";
+#endif
+        return 0;
+    }
+    // Reserve size to prepend the chunk size & append cr/lf, and get data
+    struct
+    {
+        std::size_t operator()(std::size_t n)
+        {
+            return n == 0 ? 0 : 1 + (*this)(n >> 4);
+        }
+    } neededDigits;
+    auto nHeaderSize = neededDigits(nSize) + 2;
+    auto nDataSize =
+        cbParams->dataCallback(pBuffer + nHeaderSize, nSize - nHeaderSize - 2);
+    if (nDataSize == 0)
+    {
+        // Terminal chunk + cr/lf
+        cbParams->bFinished = true;
+#ifdef _WIN32
+        memcpy_s(pBuffer, nSize, "0\r\n\r\n", 5);
+#else
+        memcpy(pBuffer, "0\r\n\r\n", 5);
+#endif
+        LOG_TRACE << "Chunking callback: no more data, return last chunk of size 0 & end of message";
+        return 5;
+    }
+    // Non-terminal chunks
+    pBuffer[nHeaderSize + nDataSize] = '\r';
+    pBuffer[nHeaderSize + nDataSize + 1] = '\n';
+    // The spec does not say if the chunk size is allowed tohave leading zeroes
+    // Use a fixed size header with leading zeroes
+    // (tested to work with Chrome, Firefox, Safari, Edge, wget, curl and VLC)
+#ifdef _WIN32
+    char pszFormat[]{"%04llx\r"};
+#else
+    char pszFormat[]{"%04lx\r"};
+#endif
+    pszFormat[2] = '0' + char(nHeaderSize - 2);
+    snprintf(pBuffer, nHeaderSize, pszFormat, nDataSize);
+    pBuffer[nHeaderSize - 1] = '\n';
+    LOG_TRACE << "Chunking callback: return chunk of size " << nDataSize;
+#ifndef NDEBUG  // defined by CMake for release build
+    cbParams->nDataReturned += nDataSize;
+#endif
+    return nHeaderSize + nDataSize + 2;
+    // Alternative code if there are client softwares that do not support chunk size with leading zeroes
+//    auto nHeaderLen =
+//#ifdef _WIN32
+//    sprintf_s(pBuffer,
+//    nHeaderSize, "%llx\r",
+//    nDataSize);
+//#else
+//    sprintf(pBuffer, "%lx\r",
+//    nDataSize);
+//#endif
+//    pBuffer[nHeaderLen++] = '\n';
+//    if (nHeaderLen < nHeaderSize)  // smaller that what was reserved -> move data
+//#ifdef _WIN32
+//    memmove_s(pBuffer +
+//    nHeaderLen,
+//              nSize - nHeaderLen,
+//              pBuffer +
+//              nHeaderSize,
+//              nDataSize + 2);
+//#else
+//    memmove(pBuffer + nHeaderLen,
+//            pBuffer + nHeaderSize,
+//            nDataSize + 2);
+//#endif
+//    return nHeaderLen + nDataSize + 2;
+}
+
 void HttpServer::sendResponse(const TcpConnectionPtr &conn,
                               const HttpResponsePtr &response,
                               bool isHeadMethod)
@@ -557,11 +662,43 @@ void HttpServer::sendResponse(const TcpConnectionPtr &conn,
     {
         auto httpString = respImplPtr->renderToBuffer();
         conn->send(httpString);
+        auto& streamCallback = respImplPtr->streamCallback();
         const std::string &sendfileName = respImplPtr->sendfileName();
-        if (!sendfileName.empty())
+        if (streamCallback || !sendfileName.empty())
         {
-            const auto &range = respImplPtr->sendfileRange();
-            conn->sendFile(sendfileName.c_str(), range.first, range.second);
+            if (streamCallback)
+            {
+                auto &headers = respImplPtr->headers();
+                // When the transfer-encoding is chunked, wrap data callback in chunking callback
+                auto bChunked =
+                    !respImplPtr->ifCloseConnection() &&
+                    (headers.find("transfer-encoding") != headers.end()) &&
+                    (headers.at("transfer-encoding") == "chunked");
+                if (bChunked)
+                {
+                    auto chunkCallback =
+                        std::bind(chunkingCallback,
+                                  std::shared_ptr<CallbackParams>(
+                                      new CallbackParams{streamCallback,
+#ifndef NDEBUG  // defined by CMake for release build
+                                                         false,
+                                                         0}),
+#else
+                                                         false}),
+#endif
+
+                                  _1,
+                                  _2);
+                    conn->sendStream(chunkCallback);
+                }
+                else
+                    conn->sendStream(streamCallback);
+            }
+            else
+            {
+                const auto &range = respImplPtr->sendfileRange();
+                conn->sendFile(sendfileName.c_str(), range.first, range.second);
+            }
         }
         COZ_PROGRESS
     }
@@ -599,13 +736,47 @@ void HttpServer::sendResponses(
         {
             // Not HEAD method
             respImplPtr->renderToBuffer(buffer);
+            auto &streamCallback = respImplPtr->streamCallback();
             const std::string &sendfileName = respImplPtr->sendfileName();
-            if (!sendfileName.empty())
+            if (streamCallback  || !sendfileName.empty())
             {
-                const auto &range = respImplPtr->sendfileRange();
                 conn->send(buffer);
                 buffer.retrieveAll();
-                conn->sendFile(sendfileName.c_str(), range.first, range.second);
+                if (streamCallback)
+                {
+                    auto &headers = respImplPtr->headers();
+                    // When the transfer-encoding is chunked, encapsulate data
+                    // callback in chunking callback
+                    auto bChunked =
+                        !respImplPtr->ifCloseConnection() &&
+                        (headers.find("transfer-encoding") != headers.end()) &&
+                        (headers.at("transfer-encoding") == "chunked");
+                    if (bChunked)
+                    {
+                        auto chunkCallback =
+                            std::bind(chunkingCallback,
+                                      std::shared_ptr<CallbackParams>(
+                                          new CallbackParams{streamCallback,
+#ifndef NDEBUG  // defined by CMake for release build
+                                                             false,
+                                                             0}),
+#else
+                                                             false}),
+#endif
+                                      _1,
+                                      _2);
+                        conn->sendStream(chunkCallback);
+                    }
+                    else
+                        conn->sendStream(streamCallback);
+                }
+                else
+                {
+                    const auto &range = respImplPtr->sendfileRange();
+                    conn->sendFile(sendfileName.c_str(),
+                                   range.first,
+                                   range.second);
+                }
                 COZ_PROGRESS
             }
         }
